// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: sensor_data.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_sensor_5fdata_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_sensor_5fdata_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3021000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3021006 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/map.h>  // IWYU pragma: export
#include <google/protobuf/map_entry.h>
#include <google/protobuf/map_field_inl.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_sensor_5fdata_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_sensor_5fdata_2eproto {
  static const uint32_t offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_sensor_5fdata_2eproto;
namespace Protos {
class IMUData;
struct IMUDataDefaultTypeInternal;
extern IMUDataDefaultTypeInternal _IMUData_default_instance_;
class IMUData_Acc;
struct IMUData_AccDefaultTypeInternal;
extern IMUData_AccDefaultTypeInternal _IMUData_Acc_default_instance_;
class IMUData_Gyro;
struct IMUData_GyroDefaultTypeInternal;
extern IMUData_GyroDefaultTypeInternal _IMUData_Gyro_default_instance_;
class IMUData_Mag;
struct IMUData_MagDefaultTypeInternal;
extern IMUData_MagDefaultTypeInternal _IMUData_Mag_default_instance_;
class PPGData;
struct PPGDataDefaultTypeInternal;
extern PPGDataDefaultTypeInternal _PPGData_default_instance_;
class PPGData_Led;
struct PPGData_LedDefaultTypeInternal;
extern PPGData_LedDefaultTypeInternal _PPGData_Led_default_instance_;
class PPGData_Temperature;
struct PPGData_TemperatureDefaultTypeInternal;
extern PPGData_TemperatureDefaultTypeInternal _PPGData_Temperature_default_instance_;
class SensorData;
struct SensorDataDefaultTypeInternal;
extern SensorDataDefaultTypeInternal _SensorData_default_instance_;
class SensorData_DataMapEntry_DoNotUse;
struct SensorData_DataMapEntry_DoNotUseDefaultTypeInternal;
extern SensorData_DataMapEntry_DoNotUseDefaultTypeInternal _SensorData_DataMapEntry_DoNotUse_default_instance_;
}  // namespace Protos
PROTOBUF_NAMESPACE_OPEN
template<> ::Protos::IMUData* Arena::CreateMaybeMessage<::Protos::IMUData>(Arena*);
template<> ::Protos::IMUData_Acc* Arena::CreateMaybeMessage<::Protos::IMUData_Acc>(Arena*);
template<> ::Protos::IMUData_Gyro* Arena::CreateMaybeMessage<::Protos::IMUData_Gyro>(Arena*);
template<> ::Protos::IMUData_Mag* Arena::CreateMaybeMessage<::Protos::IMUData_Mag>(Arena*);
template<> ::Protos::PPGData* Arena::CreateMaybeMessage<::Protos::PPGData>(Arena*);
template<> ::Protos::PPGData_Led* Arena::CreateMaybeMessage<::Protos::PPGData_Led>(Arena*);
template<> ::Protos::PPGData_Temperature* Arena::CreateMaybeMessage<::Protos::PPGData_Temperature>(Arena*);
template<> ::Protos::SensorData* Arena::CreateMaybeMessage<::Protos::SensorData>(Arena*);
template<> ::Protos::SensorData_DataMapEntry_DoNotUse* Arena::CreateMaybeMessage<::Protos::SensorData_DataMapEntry_DoNotUse>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Protos {

// ===================================================================

class SensorData_DataMapEntry_DoNotUse : public ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SensorData_DataMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> {
public:
  typedef ::PROTOBUF_NAMESPACE_ID::internal::MapEntry<SensorData_DataMapEntry_DoNotUse, 
    std::string, std::string,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> SuperType;
  SensorData_DataMapEntry_DoNotUse();
  explicit PROTOBUF_CONSTEXPR SensorData_DataMapEntry_DoNotUse(
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);
  explicit SensorData_DataMapEntry_DoNotUse(::PROTOBUF_NAMESPACE_ID::Arena* arena);
  void MergeFrom(const SensorData_DataMapEntry_DoNotUse& other);
  static const SensorData_DataMapEntry_DoNotUse* internal_default_instance() { return reinterpret_cast<const SensorData_DataMapEntry_DoNotUse*>(&_SensorData_DataMapEntry_DoNotUse_default_instance_); }
  static bool ValidateKey(std::string* s) {
    return ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(s->data(), static_cast<int>(s->size()), ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::PARSE, "Protos.SensorData.DataMapEntry.key");
 }
  static bool ValidateValue(void*) { return true; }
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;
  friend struct ::TableStruct_sensor_5fdata_2eproto;
};

// -------------------------------------------------------------------

class SensorData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protos.SensorData) */ {
 public:
  inline SensorData() : SensorData(nullptr) {}
  ~SensorData() override;
  explicit PROTOBUF_CONSTEXPR SensorData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  SensorData(const SensorData& from);
  SensorData(SensorData&& from) noexcept
    : SensorData() {
    *this = ::std::move(from);
  }

  inline SensorData& operator=(const SensorData& from) {
    CopyFrom(from);
    return *this;
  }
  inline SensorData& operator=(SensorData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const SensorData& default_instance() {
    return *internal_default_instance();
  }
  static inline const SensorData* internal_default_instance() {
    return reinterpret_cast<const SensorData*>(
               &_SensorData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(SensorData& a, SensorData& b) {
    a.Swap(&b);
  }
  inline void Swap(SensorData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(SensorData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  SensorData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<SensorData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const SensorData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const SensorData& from) {
    SensorData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(SensorData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protos.SensorData";
  }
  protected:
  explicit SensorData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  private:
  static void ArenaDtor(void* object);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------


  // accessors -------------------------------------------------------

  enum : int {
    kDataMapFieldNumber = 5,
    kPacifierIdFieldNumber = 1,
    kSensorTypeFieldNumber = 2,
    kSensorGroupFieldNumber = 3,
    kSensorPayloadTypeFieldNumber = 4,
  };
  // map<string, bytes> data_map = 5;
  int data_map_size() const;
  private:
  int _internal_data_map_size() const;
  public:
  void clear_data_map();
  private:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      _internal_data_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      _internal_mutable_data_map();
  public:
  const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
      data_map() const;
  ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
      mutable_data_map();

  // string pacifier_id = 1;
  void clear_pacifier_id();
  const std::string& pacifier_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_pacifier_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_pacifier_id();
  PROTOBUF_NODISCARD std::string* release_pacifier_id();
  void set_allocated_pacifier_id(std::string* pacifier_id);
  private:
  const std::string& _internal_pacifier_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_pacifier_id(const std::string& value);
  std::string* _internal_mutable_pacifier_id();
  public:

  // string sensor_type = 2;
  void clear_sensor_type();
  const std::string& sensor_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensor_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensor_type();
  PROTOBUF_NODISCARD std::string* release_sensor_type();
  void set_allocated_sensor_type(std::string* sensor_type);
  private:
  const std::string& _internal_sensor_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_type(const std::string& value);
  std::string* _internal_mutable_sensor_type();
  public:

  // string sensor_group = 3;
  void clear_sensor_group();
  const std::string& sensor_group() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensor_group(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensor_group();
  PROTOBUF_NODISCARD std::string* release_sensor_group();
  void set_allocated_sensor_group(std::string* sensor_group);
  private:
  const std::string& _internal_sensor_group() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_group(const std::string& value);
  std::string* _internal_mutable_sensor_group();
  public:

  // string sensor_payload_type = 4;
  void clear_sensor_payload_type();
  const std::string& sensor_payload_type() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sensor_payload_type(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sensor_payload_type();
  PROTOBUF_NODISCARD std::string* release_sensor_payload_type();
  void set_allocated_sensor_payload_type(std::string* sensor_payload_type);
  private:
  const std::string& _internal_sensor_payload_type() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sensor_payload_type(const std::string& value);
  std::string* _internal_mutable_sensor_payload_type();
  public:

  // @@protoc_insertion_point(class_scope:Protos.SensorData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::internal::MapField<
        SensorData_DataMapEntry_DoNotUse,
        std::string, std::string,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_STRING,
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::TYPE_BYTES> data_map_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr pacifier_id_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_type_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_group_;
    ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sensor_payload_type_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fdata_2eproto;
};
// -------------------------------------------------------------------

class IMUData_Gyro final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protos.IMUData.Gyro) */ {
 public:
  inline IMUData_Gyro() : IMUData_Gyro(nullptr) {}
  ~IMUData_Gyro() override;
  explicit PROTOBUF_CONSTEXPR IMUData_Gyro(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMUData_Gyro(const IMUData_Gyro& from);
  IMUData_Gyro(IMUData_Gyro&& from) noexcept
    : IMUData_Gyro() {
    *this = ::std::move(from);
  }

  inline IMUData_Gyro& operator=(const IMUData_Gyro& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMUData_Gyro& operator=(IMUData_Gyro&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMUData_Gyro& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMUData_Gyro* internal_default_instance() {
    return reinterpret_cast<const IMUData_Gyro*>(
               &_IMUData_Gyro_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(IMUData_Gyro& a, IMUData_Gyro& b) {
    a.Swap(&b);
  }
  inline void Swap(IMUData_Gyro* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMUData_Gyro* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IMUData_Gyro* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IMUData_Gyro>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMUData_Gyro& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IMUData_Gyro& from) {
    IMUData_Gyro::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMUData_Gyro* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protos.IMUData.Gyro";
  }
  protected:
  explicit IMUData_Gyro(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kGyroXFieldNumber = 1,
    kGyroYFieldNumber = 2,
    kGyroZFieldNumber = 3,
  };
  // float gyro_x = 1;
  void clear_gyro_x();
  float gyro_x() const;
  void set_gyro_x(float value);
  private:
  float _internal_gyro_x() const;
  void _internal_set_gyro_x(float value);
  public:

  // float gyro_y = 2;
  void clear_gyro_y();
  float gyro_y() const;
  void set_gyro_y(float value);
  private:
  float _internal_gyro_y() const;
  void _internal_set_gyro_y(float value);
  public:

  // float gyro_z = 3;
  void clear_gyro_z();
  float gyro_z() const;
  void set_gyro_z(float value);
  private:
  float _internal_gyro_z() const;
  void _internal_set_gyro_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protos.IMUData.Gyro)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float gyro_x_;
    float gyro_y_;
    float gyro_z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fdata_2eproto;
};
// -------------------------------------------------------------------

class IMUData_Mag final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protos.IMUData.Mag) */ {
 public:
  inline IMUData_Mag() : IMUData_Mag(nullptr) {}
  ~IMUData_Mag() override;
  explicit PROTOBUF_CONSTEXPR IMUData_Mag(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMUData_Mag(const IMUData_Mag& from);
  IMUData_Mag(IMUData_Mag&& from) noexcept
    : IMUData_Mag() {
    *this = ::std::move(from);
  }

  inline IMUData_Mag& operator=(const IMUData_Mag& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMUData_Mag& operator=(IMUData_Mag&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMUData_Mag& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMUData_Mag* internal_default_instance() {
    return reinterpret_cast<const IMUData_Mag*>(
               &_IMUData_Mag_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(IMUData_Mag& a, IMUData_Mag& b) {
    a.Swap(&b);
  }
  inline void Swap(IMUData_Mag* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMUData_Mag* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IMUData_Mag* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IMUData_Mag>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMUData_Mag& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IMUData_Mag& from) {
    IMUData_Mag::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMUData_Mag* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protos.IMUData.Mag";
  }
  protected:
  explicit IMUData_Mag(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kMagXFieldNumber = 1,
    kMagYFieldNumber = 2,
    kMagZFieldNumber = 3,
  };
  // float mag_x = 1;
  void clear_mag_x();
  float mag_x() const;
  void set_mag_x(float value);
  private:
  float _internal_mag_x() const;
  void _internal_set_mag_x(float value);
  public:

  // float mag_y = 2;
  void clear_mag_y();
  float mag_y() const;
  void set_mag_y(float value);
  private:
  float _internal_mag_y() const;
  void _internal_set_mag_y(float value);
  public:

  // float mag_z = 3;
  void clear_mag_z();
  float mag_z() const;
  void set_mag_z(float value);
  private:
  float _internal_mag_z() const;
  void _internal_set_mag_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protos.IMUData.Mag)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float mag_x_;
    float mag_y_;
    float mag_z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fdata_2eproto;
};
// -------------------------------------------------------------------

class IMUData_Acc final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protos.IMUData.Acc) */ {
 public:
  inline IMUData_Acc() : IMUData_Acc(nullptr) {}
  ~IMUData_Acc() override;
  explicit PROTOBUF_CONSTEXPR IMUData_Acc(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMUData_Acc(const IMUData_Acc& from);
  IMUData_Acc(IMUData_Acc&& from) noexcept
    : IMUData_Acc() {
    *this = ::std::move(from);
  }

  inline IMUData_Acc& operator=(const IMUData_Acc& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMUData_Acc& operator=(IMUData_Acc&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMUData_Acc& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMUData_Acc* internal_default_instance() {
    return reinterpret_cast<const IMUData_Acc*>(
               &_IMUData_Acc_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(IMUData_Acc& a, IMUData_Acc& b) {
    a.Swap(&b);
  }
  inline void Swap(IMUData_Acc* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMUData_Acc* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IMUData_Acc* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IMUData_Acc>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMUData_Acc& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IMUData_Acc& from) {
    IMUData_Acc::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMUData_Acc* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protos.IMUData.Acc";
  }
  protected:
  explicit IMUData_Acc(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAccXFieldNumber = 1,
    kAccYFieldNumber = 2,
    kAccZFieldNumber = 3,
  };
  // float acc_x = 1;
  void clear_acc_x();
  float acc_x() const;
  void set_acc_x(float value);
  private:
  float _internal_acc_x() const;
  void _internal_set_acc_x(float value);
  public:

  // float acc_y = 2;
  void clear_acc_y();
  float acc_y() const;
  void set_acc_y(float value);
  private:
  float _internal_acc_y() const;
  void _internal_set_acc_y(float value);
  public:

  // float acc_z = 3;
  void clear_acc_z();
  float acc_z() const;
  void set_acc_z(float value);
  private:
  float _internal_acc_z() const;
  void _internal_set_acc_z(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protos.IMUData.Acc)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float acc_x_;
    float acc_y_;
    float acc_z_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fdata_2eproto;
};
// -------------------------------------------------------------------

class IMUData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protos.IMUData) */ {
 public:
  inline IMUData() : IMUData(nullptr) {}
  ~IMUData() override;
  explicit PROTOBUF_CONSTEXPR IMUData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  IMUData(const IMUData& from);
  IMUData(IMUData&& from) noexcept
    : IMUData() {
    *this = ::std::move(from);
  }

  inline IMUData& operator=(const IMUData& from) {
    CopyFrom(from);
    return *this;
  }
  inline IMUData& operator=(IMUData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const IMUData& default_instance() {
    return *internal_default_instance();
  }
  static inline const IMUData* internal_default_instance() {
    return reinterpret_cast<const IMUData*>(
               &_IMUData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(IMUData& a, IMUData& b) {
    a.Swap(&b);
  }
  inline void Swap(IMUData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(IMUData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  IMUData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<IMUData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const IMUData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const IMUData& from) {
    IMUData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IMUData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protos.IMUData";
  }
  protected:
  explicit IMUData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef IMUData_Gyro Gyro;
  typedef IMUData_Mag Mag;
  typedef IMUData_Acc Acc;

  // accessors -------------------------------------------------------

  enum : int {
    kGyrosFieldNumber = 1,
    kMagsFieldNumber = 2,
    kAccsFieldNumber = 3,
  };
  // repeated .Protos.IMUData.Gyro gyros = 1;
  int gyros_size() const;
  private:
  int _internal_gyros_size() const;
  public:
  void clear_gyros();
  ::Protos::IMUData_Gyro* mutable_gyros(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Gyro >*
      mutable_gyros();
  private:
  const ::Protos::IMUData_Gyro& _internal_gyros(int index) const;
  ::Protos::IMUData_Gyro* _internal_add_gyros();
  public:
  const ::Protos::IMUData_Gyro& gyros(int index) const;
  ::Protos::IMUData_Gyro* add_gyros();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Gyro >&
      gyros() const;

  // repeated .Protos.IMUData.Mag mags = 2;
  int mags_size() const;
  private:
  int _internal_mags_size() const;
  public:
  void clear_mags();
  ::Protos::IMUData_Mag* mutable_mags(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Mag >*
      mutable_mags();
  private:
  const ::Protos::IMUData_Mag& _internal_mags(int index) const;
  ::Protos::IMUData_Mag* _internal_add_mags();
  public:
  const ::Protos::IMUData_Mag& mags(int index) const;
  ::Protos::IMUData_Mag* add_mags();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Mag >&
      mags() const;

  // repeated .Protos.IMUData.Acc accs = 3;
  int accs_size() const;
  private:
  int _internal_accs_size() const;
  public:
  void clear_accs();
  ::Protos::IMUData_Acc* mutable_accs(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Acc >*
      mutable_accs();
  private:
  const ::Protos::IMUData_Acc& _internal_accs(int index) const;
  ::Protos::IMUData_Acc* _internal_add_accs();
  public:
  const ::Protos::IMUData_Acc& accs(int index) const;
  ::Protos::IMUData_Acc* add_accs();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Acc >&
      accs() const;

  // @@protoc_insertion_point(class_scope:Protos.IMUData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Gyro > gyros_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Mag > mags_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Acc > accs_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PPGData_Led final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protos.PPGData.Led) */ {
 public:
  inline PPGData_Led() : PPGData_Led(nullptr) {}
  ~PPGData_Led() override;
  explicit PROTOBUF_CONSTEXPR PPGData_Led(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PPGData_Led(const PPGData_Led& from);
  PPGData_Led(PPGData_Led&& from) noexcept
    : PPGData_Led() {
    *this = ::std::move(from);
  }

  inline PPGData_Led& operator=(const PPGData_Led& from) {
    CopyFrom(from);
    return *this;
  }
  inline PPGData_Led& operator=(PPGData_Led&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PPGData_Led& default_instance() {
    return *internal_default_instance();
  }
  static inline const PPGData_Led* internal_default_instance() {
    return reinterpret_cast<const PPGData_Led*>(
               &_PPGData_Led_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(PPGData_Led& a, PPGData_Led& b) {
    a.Swap(&b);
  }
  inline void Swap(PPGData_Led* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PPGData_Led* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PPGData_Led* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PPGData_Led>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PPGData_Led& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PPGData_Led& from) {
    PPGData_Led::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PPGData_Led* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protos.PPGData.Led";
  }
  protected:
  explicit PPGData_Led(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kLed1FieldNumber = 1,
    kLed2FieldNumber = 2,
    kLed3FieldNumber = 3,
  };
  // int32 led_1 = 1;
  void clear_led_1();
  int32_t led_1() const;
  void set_led_1(int32_t value);
  private:
  int32_t _internal_led_1() const;
  void _internal_set_led_1(int32_t value);
  public:

  // int32 led_2 = 2;
  void clear_led_2();
  int32_t led_2() const;
  void set_led_2(int32_t value);
  private:
  int32_t _internal_led_2() const;
  void _internal_set_led_2(int32_t value);
  public:

  // int32 led_3 = 3;
  void clear_led_3();
  int32_t led_3() const;
  void set_led_3(int32_t value);
  private:
  int32_t _internal_led_3() const;
  void _internal_set_led_3(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Protos.PPGData.Led)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    int32_t led_1_;
    int32_t led_2_;
    int32_t led_3_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PPGData_Temperature final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protos.PPGData.Temperature) */ {
 public:
  inline PPGData_Temperature() : PPGData_Temperature(nullptr) {}
  ~PPGData_Temperature() override;
  explicit PROTOBUF_CONSTEXPR PPGData_Temperature(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PPGData_Temperature(const PPGData_Temperature& from);
  PPGData_Temperature(PPGData_Temperature&& from) noexcept
    : PPGData_Temperature() {
    *this = ::std::move(from);
  }

  inline PPGData_Temperature& operator=(const PPGData_Temperature& from) {
    CopyFrom(from);
    return *this;
  }
  inline PPGData_Temperature& operator=(PPGData_Temperature&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PPGData_Temperature& default_instance() {
    return *internal_default_instance();
  }
  static inline const PPGData_Temperature* internal_default_instance() {
    return reinterpret_cast<const PPGData_Temperature*>(
               &_PPGData_Temperature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(PPGData_Temperature& a, PPGData_Temperature& b) {
    a.Swap(&b);
  }
  inline void Swap(PPGData_Temperature* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PPGData_Temperature* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PPGData_Temperature* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PPGData_Temperature>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PPGData_Temperature& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PPGData_Temperature& from) {
    PPGData_Temperature::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PPGData_Temperature* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protos.PPGData.Temperature";
  }
  protected:
  explicit PPGData_Temperature(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kTemperatureFieldNumber = 1,
  };
  // float temperature = 1;
  void clear_temperature();
  float temperature() const;
  void set_temperature(float value);
  private:
  float _internal_temperature() const;
  void _internal_set_temperature(float value);
  public:

  // @@protoc_insertion_point(class_scope:Protos.PPGData.Temperature)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    float temperature_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fdata_2eproto;
};
// -------------------------------------------------------------------

class PPGData final :
    public ::PROTOBUF_NAMESPACE_ID::Message /* @@protoc_insertion_point(class_definition:Protos.PPGData) */ {
 public:
  inline PPGData() : PPGData(nullptr) {}
  ~PPGData() override;
  explicit PROTOBUF_CONSTEXPR PPGData(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  PPGData(const PPGData& from);
  PPGData(PPGData&& from) noexcept
    : PPGData() {
    *this = ::std::move(from);
  }

  inline PPGData& operator=(const PPGData& from) {
    CopyFrom(from);
    return *this;
  }
  inline PPGData& operator=(PPGData&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* descriptor() {
    return GetDescriptor();
  }
  static const ::PROTOBUF_NAMESPACE_ID::Descriptor* GetDescriptor() {
    return default_instance().GetMetadata().descriptor;
  }
  static const ::PROTOBUF_NAMESPACE_ID::Reflection* GetReflection() {
    return default_instance().GetMetadata().reflection;
  }
  static const PPGData& default_instance() {
    return *internal_default_instance();
  }
  static inline const PPGData* internal_default_instance() {
    return reinterpret_cast<const PPGData*>(
               &_PPGData_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(PPGData& a, PPGData& b) {
    a.Swap(&b);
  }
  inline void Swap(PPGData* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(PPGData* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  PPGData* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<PPGData>(arena);
  }
  using ::PROTOBUF_NAMESPACE_ID::Message::CopyFrom;
  void CopyFrom(const PPGData& from);
  using ::PROTOBUF_NAMESPACE_ID::Message::MergeFrom;
  void MergeFrom( const PPGData& from) {
    PPGData::MergeImpl(*this, from);
  }
  private:
  static void MergeImpl(::PROTOBUF_NAMESPACE_ID::Message& to_msg, const ::PROTOBUF_NAMESPACE_ID::Message& from_msg);
  public:
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _impl_._cached_size_.Get(); }

  private:
  void SharedCtor(::PROTOBUF_NAMESPACE_ID::Arena* arena, bool is_message_owned);
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(PPGData* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Protos.PPGData";
  }
  protected:
  explicit PPGData(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  static const ClassData _class_data_;
  const ::PROTOBUF_NAMESPACE_ID::Message::ClassData*GetClassData() const final;

  ::PROTOBUF_NAMESPACE_ID::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef PPGData_Led Led;
  typedef PPGData_Temperature Temperature;

  // accessors -------------------------------------------------------

  enum : int {
    kLedsFieldNumber = 1,
    kTemperaturesFieldNumber = 2,
  };
  // repeated .Protos.PPGData.Led leds = 1;
  int leds_size() const;
  private:
  int _internal_leds_size() const;
  public:
  void clear_leds();
  ::Protos::PPGData_Led* mutable_leds(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::PPGData_Led >*
      mutable_leds();
  private:
  const ::Protos::PPGData_Led& _internal_leds(int index) const;
  ::Protos::PPGData_Led* _internal_add_leds();
  public:
  const ::Protos::PPGData_Led& leds(int index) const;
  ::Protos::PPGData_Led* add_leds();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::PPGData_Led >&
      leds() const;

  // repeated .Protos.PPGData.Temperature temperatures = 2;
  int temperatures_size() const;
  private:
  int _internal_temperatures_size() const;
  public:
  void clear_temperatures();
  ::Protos::PPGData_Temperature* mutable_temperatures(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::PPGData_Temperature >*
      mutable_temperatures();
  private:
  const ::Protos::PPGData_Temperature& _internal_temperatures(int index) const;
  ::Protos::PPGData_Temperature* _internal_add_temperatures();
  public:
  const ::Protos::PPGData_Temperature& temperatures(int index) const;
  ::Protos::PPGData_Temperature* add_temperatures();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::PPGData_Temperature >&
      temperatures() const;

  // @@protoc_insertion_point(class_scope:Protos.PPGData)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  struct Impl_ {
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::PPGData_Led > leds_;
    ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::PPGData_Temperature > temperatures_;
    mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  };
  union { Impl_ _impl_; };
  friend struct ::TableStruct_sensor_5fdata_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// -------------------------------------------------------------------

// SensorData

// string pacifier_id = 1;
inline void SensorData::clear_pacifier_id() {
  _impl_.pacifier_id_.ClearToEmpty();
}
inline const std::string& SensorData::pacifier_id() const {
  // @@protoc_insertion_point(field_get:Protos.SensorData.pacifier_id)
  return _internal_pacifier_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorData::set_pacifier_id(ArgT0&& arg0, ArgT... args) {
 
 _impl_.pacifier_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protos.SensorData.pacifier_id)
}
inline std::string* SensorData::mutable_pacifier_id() {
  std::string* _s = _internal_mutable_pacifier_id();
  // @@protoc_insertion_point(field_mutable:Protos.SensorData.pacifier_id)
  return _s;
}
inline const std::string& SensorData::_internal_pacifier_id() const {
  return _impl_.pacifier_id_.Get();
}
inline void SensorData::_internal_set_pacifier_id(const std::string& value) {
  
  _impl_.pacifier_id_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorData::_internal_mutable_pacifier_id() {
  
  return _impl_.pacifier_id_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorData::release_pacifier_id() {
  // @@protoc_insertion_point(field_release:Protos.SensorData.pacifier_id)
  return _impl_.pacifier_id_.Release();
}
inline void SensorData::set_allocated_pacifier_id(std::string* pacifier_id) {
  if (pacifier_id != nullptr) {
    
  } else {
    
  }
  _impl_.pacifier_id_.SetAllocated(pacifier_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.pacifier_id_.IsDefault()) {
    _impl_.pacifier_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protos.SensorData.pacifier_id)
}

// string sensor_type = 2;
inline void SensorData::clear_sensor_type() {
  _impl_.sensor_type_.ClearToEmpty();
}
inline const std::string& SensorData::sensor_type() const {
  // @@protoc_insertion_point(field_get:Protos.SensorData.sensor_type)
  return _internal_sensor_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorData::set_sensor_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sensor_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protos.SensorData.sensor_type)
}
inline std::string* SensorData::mutable_sensor_type() {
  std::string* _s = _internal_mutable_sensor_type();
  // @@protoc_insertion_point(field_mutable:Protos.SensorData.sensor_type)
  return _s;
}
inline const std::string& SensorData::_internal_sensor_type() const {
  return _impl_.sensor_type_.Get();
}
inline void SensorData::_internal_set_sensor_type(const std::string& value) {
  
  _impl_.sensor_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorData::_internal_mutable_sensor_type() {
  
  return _impl_.sensor_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorData::release_sensor_type() {
  // @@protoc_insertion_point(field_release:Protos.SensorData.sensor_type)
  return _impl_.sensor_type_.Release();
}
inline void SensorData::set_allocated_sensor_type(std::string* sensor_type) {
  if (sensor_type != nullptr) {
    
  } else {
    
  }
  _impl_.sensor_type_.SetAllocated(sensor_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sensor_type_.IsDefault()) {
    _impl_.sensor_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protos.SensorData.sensor_type)
}

// string sensor_group = 3;
inline void SensorData::clear_sensor_group() {
  _impl_.sensor_group_.ClearToEmpty();
}
inline const std::string& SensorData::sensor_group() const {
  // @@protoc_insertion_point(field_get:Protos.SensorData.sensor_group)
  return _internal_sensor_group();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorData::set_sensor_group(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sensor_group_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protos.SensorData.sensor_group)
}
inline std::string* SensorData::mutable_sensor_group() {
  std::string* _s = _internal_mutable_sensor_group();
  // @@protoc_insertion_point(field_mutable:Protos.SensorData.sensor_group)
  return _s;
}
inline const std::string& SensorData::_internal_sensor_group() const {
  return _impl_.sensor_group_.Get();
}
inline void SensorData::_internal_set_sensor_group(const std::string& value) {
  
  _impl_.sensor_group_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorData::_internal_mutable_sensor_group() {
  
  return _impl_.sensor_group_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorData::release_sensor_group() {
  // @@protoc_insertion_point(field_release:Protos.SensorData.sensor_group)
  return _impl_.sensor_group_.Release();
}
inline void SensorData::set_allocated_sensor_group(std::string* sensor_group) {
  if (sensor_group != nullptr) {
    
  } else {
    
  }
  _impl_.sensor_group_.SetAllocated(sensor_group, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sensor_group_.IsDefault()) {
    _impl_.sensor_group_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protos.SensorData.sensor_group)
}

// string sensor_payload_type = 4;
inline void SensorData::clear_sensor_payload_type() {
  _impl_.sensor_payload_type_.ClearToEmpty();
}
inline const std::string& SensorData::sensor_payload_type() const {
  // @@protoc_insertion_point(field_get:Protos.SensorData.sensor_payload_type)
  return _internal_sensor_payload_type();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void SensorData::set_sensor_payload_type(ArgT0&& arg0, ArgT... args) {
 
 _impl_.sensor_payload_type_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Protos.SensorData.sensor_payload_type)
}
inline std::string* SensorData::mutable_sensor_payload_type() {
  std::string* _s = _internal_mutable_sensor_payload_type();
  // @@protoc_insertion_point(field_mutable:Protos.SensorData.sensor_payload_type)
  return _s;
}
inline const std::string& SensorData::_internal_sensor_payload_type() const {
  return _impl_.sensor_payload_type_.Get();
}
inline void SensorData::_internal_set_sensor_payload_type(const std::string& value) {
  
  _impl_.sensor_payload_type_.Set(value, GetArenaForAllocation());
}
inline std::string* SensorData::_internal_mutable_sensor_payload_type() {
  
  return _impl_.sensor_payload_type_.Mutable(GetArenaForAllocation());
}
inline std::string* SensorData::release_sensor_payload_type() {
  // @@protoc_insertion_point(field_release:Protos.SensorData.sensor_payload_type)
  return _impl_.sensor_payload_type_.Release();
}
inline void SensorData::set_allocated_sensor_payload_type(std::string* sensor_payload_type) {
  if (sensor_payload_type != nullptr) {
    
  } else {
    
  }
  _impl_.sensor_payload_type_.SetAllocated(sensor_payload_type, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (_impl_.sensor_payload_type_.IsDefault()) {
    _impl_.sensor_payload_type_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Protos.SensorData.sensor_payload_type)
}

// map<string, bytes> data_map = 5;
inline int SensorData::_internal_data_map_size() const {
  return _impl_.data_map_.size();
}
inline int SensorData::data_map_size() const {
  return _internal_data_map_size();
}
inline void SensorData::clear_data_map() {
  _impl_.data_map_.Clear();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SensorData::_internal_data_map() const {
  return _impl_.data_map_.GetMap();
}
inline const ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >&
SensorData::data_map() const {
  // @@protoc_insertion_point(field_map:Protos.SensorData.data_map)
  return _internal_data_map();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SensorData::_internal_mutable_data_map() {
  return _impl_.data_map_.MutableMap();
}
inline ::PROTOBUF_NAMESPACE_ID::Map< std::string, std::string >*
SensorData::mutable_data_map() {
  // @@protoc_insertion_point(field_mutable_map:Protos.SensorData.data_map)
  return _internal_mutable_data_map();
}

// -------------------------------------------------------------------

// IMUData_Gyro

// float gyro_x = 1;
inline void IMUData_Gyro::clear_gyro_x() {
  _impl_.gyro_x_ = 0;
}
inline float IMUData_Gyro::_internal_gyro_x() const {
  return _impl_.gyro_x_;
}
inline float IMUData_Gyro::gyro_x() const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.Gyro.gyro_x)
  return _internal_gyro_x();
}
inline void IMUData_Gyro::_internal_set_gyro_x(float value) {
  
  _impl_.gyro_x_ = value;
}
inline void IMUData_Gyro::set_gyro_x(float value) {
  _internal_set_gyro_x(value);
  // @@protoc_insertion_point(field_set:Protos.IMUData.Gyro.gyro_x)
}

// float gyro_y = 2;
inline void IMUData_Gyro::clear_gyro_y() {
  _impl_.gyro_y_ = 0;
}
inline float IMUData_Gyro::_internal_gyro_y() const {
  return _impl_.gyro_y_;
}
inline float IMUData_Gyro::gyro_y() const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.Gyro.gyro_y)
  return _internal_gyro_y();
}
inline void IMUData_Gyro::_internal_set_gyro_y(float value) {
  
  _impl_.gyro_y_ = value;
}
inline void IMUData_Gyro::set_gyro_y(float value) {
  _internal_set_gyro_y(value);
  // @@protoc_insertion_point(field_set:Protos.IMUData.Gyro.gyro_y)
}

// float gyro_z = 3;
inline void IMUData_Gyro::clear_gyro_z() {
  _impl_.gyro_z_ = 0;
}
inline float IMUData_Gyro::_internal_gyro_z() const {
  return _impl_.gyro_z_;
}
inline float IMUData_Gyro::gyro_z() const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.Gyro.gyro_z)
  return _internal_gyro_z();
}
inline void IMUData_Gyro::_internal_set_gyro_z(float value) {
  
  _impl_.gyro_z_ = value;
}
inline void IMUData_Gyro::set_gyro_z(float value) {
  _internal_set_gyro_z(value);
  // @@protoc_insertion_point(field_set:Protos.IMUData.Gyro.gyro_z)
}

// -------------------------------------------------------------------

// IMUData_Mag

// float mag_x = 1;
inline void IMUData_Mag::clear_mag_x() {
  _impl_.mag_x_ = 0;
}
inline float IMUData_Mag::_internal_mag_x() const {
  return _impl_.mag_x_;
}
inline float IMUData_Mag::mag_x() const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.Mag.mag_x)
  return _internal_mag_x();
}
inline void IMUData_Mag::_internal_set_mag_x(float value) {
  
  _impl_.mag_x_ = value;
}
inline void IMUData_Mag::set_mag_x(float value) {
  _internal_set_mag_x(value);
  // @@protoc_insertion_point(field_set:Protos.IMUData.Mag.mag_x)
}

// float mag_y = 2;
inline void IMUData_Mag::clear_mag_y() {
  _impl_.mag_y_ = 0;
}
inline float IMUData_Mag::_internal_mag_y() const {
  return _impl_.mag_y_;
}
inline float IMUData_Mag::mag_y() const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.Mag.mag_y)
  return _internal_mag_y();
}
inline void IMUData_Mag::_internal_set_mag_y(float value) {
  
  _impl_.mag_y_ = value;
}
inline void IMUData_Mag::set_mag_y(float value) {
  _internal_set_mag_y(value);
  // @@protoc_insertion_point(field_set:Protos.IMUData.Mag.mag_y)
}

// float mag_z = 3;
inline void IMUData_Mag::clear_mag_z() {
  _impl_.mag_z_ = 0;
}
inline float IMUData_Mag::_internal_mag_z() const {
  return _impl_.mag_z_;
}
inline float IMUData_Mag::mag_z() const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.Mag.mag_z)
  return _internal_mag_z();
}
inline void IMUData_Mag::_internal_set_mag_z(float value) {
  
  _impl_.mag_z_ = value;
}
inline void IMUData_Mag::set_mag_z(float value) {
  _internal_set_mag_z(value);
  // @@protoc_insertion_point(field_set:Protos.IMUData.Mag.mag_z)
}

// -------------------------------------------------------------------

// IMUData_Acc

// float acc_x = 1;
inline void IMUData_Acc::clear_acc_x() {
  _impl_.acc_x_ = 0;
}
inline float IMUData_Acc::_internal_acc_x() const {
  return _impl_.acc_x_;
}
inline float IMUData_Acc::acc_x() const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.Acc.acc_x)
  return _internal_acc_x();
}
inline void IMUData_Acc::_internal_set_acc_x(float value) {
  
  _impl_.acc_x_ = value;
}
inline void IMUData_Acc::set_acc_x(float value) {
  _internal_set_acc_x(value);
  // @@protoc_insertion_point(field_set:Protos.IMUData.Acc.acc_x)
}

// float acc_y = 2;
inline void IMUData_Acc::clear_acc_y() {
  _impl_.acc_y_ = 0;
}
inline float IMUData_Acc::_internal_acc_y() const {
  return _impl_.acc_y_;
}
inline float IMUData_Acc::acc_y() const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.Acc.acc_y)
  return _internal_acc_y();
}
inline void IMUData_Acc::_internal_set_acc_y(float value) {
  
  _impl_.acc_y_ = value;
}
inline void IMUData_Acc::set_acc_y(float value) {
  _internal_set_acc_y(value);
  // @@protoc_insertion_point(field_set:Protos.IMUData.Acc.acc_y)
}

// float acc_z = 3;
inline void IMUData_Acc::clear_acc_z() {
  _impl_.acc_z_ = 0;
}
inline float IMUData_Acc::_internal_acc_z() const {
  return _impl_.acc_z_;
}
inline float IMUData_Acc::acc_z() const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.Acc.acc_z)
  return _internal_acc_z();
}
inline void IMUData_Acc::_internal_set_acc_z(float value) {
  
  _impl_.acc_z_ = value;
}
inline void IMUData_Acc::set_acc_z(float value) {
  _internal_set_acc_z(value);
  // @@protoc_insertion_point(field_set:Protos.IMUData.Acc.acc_z)
}

// -------------------------------------------------------------------

// IMUData

// repeated .Protos.IMUData.Gyro gyros = 1;
inline int IMUData::_internal_gyros_size() const {
  return _impl_.gyros_.size();
}
inline int IMUData::gyros_size() const {
  return _internal_gyros_size();
}
inline void IMUData::clear_gyros() {
  _impl_.gyros_.Clear();
}
inline ::Protos::IMUData_Gyro* IMUData::mutable_gyros(int index) {
  // @@protoc_insertion_point(field_mutable:Protos.IMUData.gyros)
  return _impl_.gyros_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Gyro >*
IMUData::mutable_gyros() {
  // @@protoc_insertion_point(field_mutable_list:Protos.IMUData.gyros)
  return &_impl_.gyros_;
}
inline const ::Protos::IMUData_Gyro& IMUData::_internal_gyros(int index) const {
  return _impl_.gyros_.Get(index);
}
inline const ::Protos::IMUData_Gyro& IMUData::gyros(int index) const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.gyros)
  return _internal_gyros(index);
}
inline ::Protos::IMUData_Gyro* IMUData::_internal_add_gyros() {
  return _impl_.gyros_.Add();
}
inline ::Protos::IMUData_Gyro* IMUData::add_gyros() {
  ::Protos::IMUData_Gyro* _add = _internal_add_gyros();
  // @@protoc_insertion_point(field_add:Protos.IMUData.gyros)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Gyro >&
IMUData::gyros() const {
  // @@protoc_insertion_point(field_list:Protos.IMUData.gyros)
  return _impl_.gyros_;
}

// repeated .Protos.IMUData.Mag mags = 2;
inline int IMUData::_internal_mags_size() const {
  return _impl_.mags_.size();
}
inline int IMUData::mags_size() const {
  return _internal_mags_size();
}
inline void IMUData::clear_mags() {
  _impl_.mags_.Clear();
}
inline ::Protos::IMUData_Mag* IMUData::mutable_mags(int index) {
  // @@protoc_insertion_point(field_mutable:Protos.IMUData.mags)
  return _impl_.mags_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Mag >*
IMUData::mutable_mags() {
  // @@protoc_insertion_point(field_mutable_list:Protos.IMUData.mags)
  return &_impl_.mags_;
}
inline const ::Protos::IMUData_Mag& IMUData::_internal_mags(int index) const {
  return _impl_.mags_.Get(index);
}
inline const ::Protos::IMUData_Mag& IMUData::mags(int index) const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.mags)
  return _internal_mags(index);
}
inline ::Protos::IMUData_Mag* IMUData::_internal_add_mags() {
  return _impl_.mags_.Add();
}
inline ::Protos::IMUData_Mag* IMUData::add_mags() {
  ::Protos::IMUData_Mag* _add = _internal_add_mags();
  // @@protoc_insertion_point(field_add:Protos.IMUData.mags)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Mag >&
IMUData::mags() const {
  // @@protoc_insertion_point(field_list:Protos.IMUData.mags)
  return _impl_.mags_;
}

// repeated .Protos.IMUData.Acc accs = 3;
inline int IMUData::_internal_accs_size() const {
  return _impl_.accs_.size();
}
inline int IMUData::accs_size() const {
  return _internal_accs_size();
}
inline void IMUData::clear_accs() {
  _impl_.accs_.Clear();
}
inline ::Protos::IMUData_Acc* IMUData::mutable_accs(int index) {
  // @@protoc_insertion_point(field_mutable:Protos.IMUData.accs)
  return _impl_.accs_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Acc >*
IMUData::mutable_accs() {
  // @@protoc_insertion_point(field_mutable_list:Protos.IMUData.accs)
  return &_impl_.accs_;
}
inline const ::Protos::IMUData_Acc& IMUData::_internal_accs(int index) const {
  return _impl_.accs_.Get(index);
}
inline const ::Protos::IMUData_Acc& IMUData::accs(int index) const {
  // @@protoc_insertion_point(field_get:Protos.IMUData.accs)
  return _internal_accs(index);
}
inline ::Protos::IMUData_Acc* IMUData::_internal_add_accs() {
  return _impl_.accs_.Add();
}
inline ::Protos::IMUData_Acc* IMUData::add_accs() {
  ::Protos::IMUData_Acc* _add = _internal_add_accs();
  // @@protoc_insertion_point(field_add:Protos.IMUData.accs)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::IMUData_Acc >&
IMUData::accs() const {
  // @@protoc_insertion_point(field_list:Protos.IMUData.accs)
  return _impl_.accs_;
}

// -------------------------------------------------------------------

// PPGData_Led

// int32 led_1 = 1;
inline void PPGData_Led::clear_led_1() {
  _impl_.led_1_ = 0;
}
inline int32_t PPGData_Led::_internal_led_1() const {
  return _impl_.led_1_;
}
inline int32_t PPGData_Led::led_1() const {
  // @@protoc_insertion_point(field_get:Protos.PPGData.Led.led_1)
  return _internal_led_1();
}
inline void PPGData_Led::_internal_set_led_1(int32_t value) {
  
  _impl_.led_1_ = value;
}
inline void PPGData_Led::set_led_1(int32_t value) {
  _internal_set_led_1(value);
  // @@protoc_insertion_point(field_set:Protos.PPGData.Led.led_1)
}

// int32 led_2 = 2;
inline void PPGData_Led::clear_led_2() {
  _impl_.led_2_ = 0;
}
inline int32_t PPGData_Led::_internal_led_2() const {
  return _impl_.led_2_;
}
inline int32_t PPGData_Led::led_2() const {
  // @@protoc_insertion_point(field_get:Protos.PPGData.Led.led_2)
  return _internal_led_2();
}
inline void PPGData_Led::_internal_set_led_2(int32_t value) {
  
  _impl_.led_2_ = value;
}
inline void PPGData_Led::set_led_2(int32_t value) {
  _internal_set_led_2(value);
  // @@protoc_insertion_point(field_set:Protos.PPGData.Led.led_2)
}

// int32 led_3 = 3;
inline void PPGData_Led::clear_led_3() {
  _impl_.led_3_ = 0;
}
inline int32_t PPGData_Led::_internal_led_3() const {
  return _impl_.led_3_;
}
inline int32_t PPGData_Led::led_3() const {
  // @@protoc_insertion_point(field_get:Protos.PPGData.Led.led_3)
  return _internal_led_3();
}
inline void PPGData_Led::_internal_set_led_3(int32_t value) {
  
  _impl_.led_3_ = value;
}
inline void PPGData_Led::set_led_3(int32_t value) {
  _internal_set_led_3(value);
  // @@protoc_insertion_point(field_set:Protos.PPGData.Led.led_3)
}

// -------------------------------------------------------------------

// PPGData_Temperature

// float temperature = 1;
inline void PPGData_Temperature::clear_temperature() {
  _impl_.temperature_ = 0;
}
inline float PPGData_Temperature::_internal_temperature() const {
  return _impl_.temperature_;
}
inline float PPGData_Temperature::temperature() const {
  // @@protoc_insertion_point(field_get:Protos.PPGData.Temperature.temperature)
  return _internal_temperature();
}
inline void PPGData_Temperature::_internal_set_temperature(float value) {
  
  _impl_.temperature_ = value;
}
inline void PPGData_Temperature::set_temperature(float value) {
  _internal_set_temperature(value);
  // @@protoc_insertion_point(field_set:Protos.PPGData.Temperature.temperature)
}

// -------------------------------------------------------------------

// PPGData

// repeated .Protos.PPGData.Led leds = 1;
inline int PPGData::_internal_leds_size() const {
  return _impl_.leds_.size();
}
inline int PPGData::leds_size() const {
  return _internal_leds_size();
}
inline void PPGData::clear_leds() {
  _impl_.leds_.Clear();
}
inline ::Protos::PPGData_Led* PPGData::mutable_leds(int index) {
  // @@protoc_insertion_point(field_mutable:Protos.PPGData.leds)
  return _impl_.leds_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::PPGData_Led >*
PPGData::mutable_leds() {
  // @@protoc_insertion_point(field_mutable_list:Protos.PPGData.leds)
  return &_impl_.leds_;
}
inline const ::Protos::PPGData_Led& PPGData::_internal_leds(int index) const {
  return _impl_.leds_.Get(index);
}
inline const ::Protos::PPGData_Led& PPGData::leds(int index) const {
  // @@protoc_insertion_point(field_get:Protos.PPGData.leds)
  return _internal_leds(index);
}
inline ::Protos::PPGData_Led* PPGData::_internal_add_leds() {
  return _impl_.leds_.Add();
}
inline ::Protos::PPGData_Led* PPGData::add_leds() {
  ::Protos::PPGData_Led* _add = _internal_add_leds();
  // @@protoc_insertion_point(field_add:Protos.PPGData.leds)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::PPGData_Led >&
PPGData::leds() const {
  // @@protoc_insertion_point(field_list:Protos.PPGData.leds)
  return _impl_.leds_;
}

// repeated .Protos.PPGData.Temperature temperatures = 2;
inline int PPGData::_internal_temperatures_size() const {
  return _impl_.temperatures_.size();
}
inline int PPGData::temperatures_size() const {
  return _internal_temperatures_size();
}
inline void PPGData::clear_temperatures() {
  _impl_.temperatures_.Clear();
}
inline ::Protos::PPGData_Temperature* PPGData::mutable_temperatures(int index) {
  // @@protoc_insertion_point(field_mutable:Protos.PPGData.temperatures)
  return _impl_.temperatures_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::PPGData_Temperature >*
PPGData::mutable_temperatures() {
  // @@protoc_insertion_point(field_mutable_list:Protos.PPGData.temperatures)
  return &_impl_.temperatures_;
}
inline const ::Protos::PPGData_Temperature& PPGData::_internal_temperatures(int index) const {
  return _impl_.temperatures_.Get(index);
}
inline const ::Protos::PPGData_Temperature& PPGData::temperatures(int index) const {
  // @@protoc_insertion_point(field_get:Protos.PPGData.temperatures)
  return _internal_temperatures(index);
}
inline ::Protos::PPGData_Temperature* PPGData::_internal_add_temperatures() {
  return _impl_.temperatures_.Add();
}
inline ::Protos::PPGData_Temperature* PPGData::add_temperatures() {
  ::Protos::PPGData_Temperature* _add = _internal_add_temperatures();
  // @@protoc_insertion_point(field_add:Protos.PPGData.temperatures)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Protos::PPGData_Temperature >&
PPGData::temperatures() const {
  // @@protoc_insertion_point(field_list:Protos.PPGData.temperatures)
  return _impl_.temperatures_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Protos

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_sensor_5fdata_2eproto
